import logging
import random
import asyncio
from typing import Dict, List, Any, Optional
from datetime import datetime
import uuid
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update
from sqlalchemy.orm import selectinload

from app.utils.simulation import simulate_network_delay, simulate_failures, calculate_risk_score
from app.services.device_scanner import create_device_scanner
from app.models.scan import Scan, VulnerabilityScan
from app.models.device import Device
from app.core.logging import logger

class VulnerabilityScanner:
    """Advanced vulnerability scanner for IoT devices"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
        self._scan_lock = asyncio.Lock()
        self.cve_database = self._initialize_cve_database()
        # Create a device scanner to fetch device data
        self.device_scanner = create_device_scanner(db)
    
    def _initialize_cve_database(self) -> Dict[str, List[Dict[str, Any]]]:
        """Initialize a database of common vulnerabilities by device type"""
        return {
            "router": [
                {
                    "id": "CVE-2020-1472",
                    "name": "Zerologon",
                    "description": "Critical vulnerability in Windows Server Netlogon Remote Protocol",
                    "severity": "CRITICAL",
                    "cvss_score": 10.0,
                    "affected_vendors": ["Microsoft", "All"],
                    "remediation": "Apply security patches from Microsoft"
                },
                {
                    "id": "CVE-2019-1653",
                    "name": "Cisco Router Information Disclosure",
                    "description": "Sensitive information disclosure in web management interface",
                    "severity": "HIGH",
                    "cvss_score": 8.1,
                    "affected_vendors": ["Cisco", "All"],
                    "remediation": "Update router firmware to latest version"
                },
                {
                    "id": "CVE-2021-44228",
                    "name": "Log4Shell",
                    "description": "Remote code execution vulnerability in Apache Log4j library",
                    "severity": "CRITICAL", 
                    "cvss_score": 10.0,
                    "affected_vendors": ["All"],
                    "remediation": "Update Log4j to version 2.15.0 or higher"
                },
                {
                    "id": "CVE-2018-10562",
                    "name": "GPON Router Authentication Bypass",
                    "description": "Authentication bypass vulnerability in GPON routers",
                    "severity": "HIGH",
                    "cvss_score": 9.8,
                    "affected_vendors": ["Multiple"],
                    "remediation": "Update router firmware or implement network-based protections"
                }
            ],
            "camera": [
                {
                    "id": "CVE-2021-32934",
                    "name": "IP Camera Unauthenticated Access",
                    "description": "Unauthenticated access to camera feeds and configuration",
                    "severity": "HIGH",
                    "cvss_score": 8.8,
                    "affected_vendors": ["Multiple"],
                    "remediation": "Update firmware and enable authentication"
                },
                {
                    "id": "CVE-2020-9479",
                    "name": "RTSP Stream Hijacking",
                    "description": "Authentication bypass in RTSP protocol implementation",
                    "severity": "MEDIUM",
                    "cvss_score": 6.5,
                    "affected_vendors": ["Multiple"],
                    "remediation": "Enable RTSP authentication and update firmware"
                }
            ],
            "thermostat": [
                {
                    "id": "CVE-2019-5632",
                    "name": "Smart Thermostat Information Leak",
                    "description": "Information disclosure vulnerability in smart thermostat APIs",
                    "severity": "MEDIUM",
                    "cvss_score": 5.5,
                    "affected_vendors": ["Multiple"],
                    "remediation": "Update firmware to latest version"
                }
            ],
            "general": [
                {
                    "id": "CVE-2022-22965",
                    "name": "Spring4Shell",
                    "description": "Remote code execution vulnerability in Spring Framework",
                    "severity": "HIGH",
                    "cvss_score": 9.8,
                    "affected_vendors": ["All"],
                    "remediation": "Update Spring Framework to patched version"
                },
                {
                    "id": "CVE-2018-0171",
                    "name": "SSDP Service Buffer Overflow",
                    "description": "Buffer overflow in SSDP service leading to remote code execution",
                    "severity": "HIGH",
                    "cvss_score": 8.1,
                    "affected_vendors": ["Multiple"],
                    "remediation": "Update firmware and disable SSDP service if not needed"
                },
                {
                    "id": "CVE-2022-generic-1",
                    "name": "Default Credentials",
                    "description": "Device using default manufacturer credentials",
                    "severity": "HIGH",
                    "cvss_score": 8.8,
                    "affected_vendors": ["All"],
                    "remediation": "Change default credentials immediately"
                },
                {
                    "id": "CVE-2022-generic-2",
                    "name": "Outdated Firmware",
                    "description": "Device running outdated firmware version vulnerable to known vulnerabilities",
                    "severity": "MEDIUM",
                    "cvss_score": 5.4,
                    "affected_vendors": ["All"],
                    "remediation": "Update device firmware to latest version"
                }
            ]
        }
    
    async def cleanup(self):
        """Clean up scanner resources"""
        logger.info("Cleaning up vulnerability scanner resources")
        await self.device_scanner.cleanup()
    
    async def start_vulnerability_scan(self, device_ids: Optional[List[int]] = None, scan_id: Optional[str] = None) -> str:
        """Start a new vulnerability scan and return its ID"""
        async with self._scan_lock:
            # If scan_id is provided, use it (for integration with new background task system)
            # Otherwise create a new scan record
            if scan_id is None:
                # Check for any running scans
                running_scan = await self.db.execute(
                    select(Scan).where(Scan.status == "running")
                )
                if running_scan.scalar_one_or_none():
                    raise RuntimeError("A scan is already running")
                
                # Create new scan record
                scan_id = str(uuid.uuid4())
                scan = Scan(
                    id=scan_id,
                    status="running",
                    scan_type="vulnerability",
                    start_time=datetime.utcnow()
                )
                self.db.add(scan)
                await self.db.commit()
                
                # Start scan in background
                asyncio.create_task(self._run_vulnerability_scan(scan_id, device_ids))
            else:
                # Update existing scan to running status
                await self.db.execute(
                    update(Scan)
                    .where(Scan.id == scan_id)
                    .values(status="running")
                )
                await self.db.commit()
                
                # Run the scan directly since we're already in a background task
                await self._run_vulnerability_scan(scan_id, device_ids)
                
            return scan_id
    
    async def get_scan_status(self, scan_id: str) -> Dict:
        """Get the status of a vulnerability scan"""
        scan = await self.db.execute(
            select(Scan)
            .options(selectinload(Scan.vulnerability_scans))
            .where(Scan.id == scan_id)
        )
        scan = scan.scalar_one_or_none()
        if not scan:
            raise ValueError(f"Scan {scan_id} not found")
        
        # Get vulnerability scan results
        vuln_scans = await self.db.execute(
            select(VulnerabilityScan)
            .where(VulnerabilityScan.scan_id == scan_id)
        )
        vuln_scans = vuln_scans.scalars().all()
        
        return {
            "id": scan.id,
            "status": scan.status,
            "scan_type": scan.scan_type,
            "start_time": scan.start_time,
            "end_time": scan.end_time,
            "error": scan.error,
            "results": [
                {
                    "device_id": vs.device_id,
                    "status": vs.status,
                    "vulnerabilities": vs.vulnerabilities,
                    "risk_score": vs.risk_score,
                    "timestamp": vs.timestamp,
                    "error": vs.error
                }
                for vs in vuln_scans
            ]
        }
    
    async def _run_vulnerability_scan(self, scan_id: str, device_ids: Optional[List[int]] = None):
        """Run the vulnerability scan operation"""
        try:
            # Update scan status to running
            await self.db.execute(
                update(Scan)
                .where(Scan.id == scan_id)
                .values(status="running")
            )
            await self.db.commit()
            
            # Get devices to scan
            if device_ids and len(device_ids) > 0:
                # Scan specific devices
                devices = await self.db.execute(
                    select(Device).where(Device.id.in_(device_ids))
                )
            else:
                # Scan all active devices
                devices = await self.db.execute(
                    select(Device).where(Device.is_online == True)
                )
            devices = devices.scalars().all()
            
            # Check if we found any devices
            if not devices:
                logger.warning(f"No devices found for vulnerability scan {scan_id}")
                await self.db.execute(
                    update(Scan)
                    .where(Scan.id == scan_id)
                    .values(
                        status="completed",
                        end_time=datetime.utcnow(),
                        results={"message": "No devices found to scan", "devices_scanned": 0}
                    )
                )
                await self.db.commit()
                return
            
            for device in devices:
                try:
                    # Create vulnerability scan record for this device
                    vuln_scan = VulnerabilityScan(
                        scan_id=scan_id,
                        device_id=device.id,
                        status="running",
                        timestamp=datetime.utcnow()
                    )
                    self.db.add(vuln_scan)
                    await self.db.commit()
                    
                    # Run vulnerability scan for this device
                    vulnerabilities = await self._scan_device(device)
                    risk_score = self._calculate_risk_score(vulnerabilities)
                    
                    # Update vulnerability scan record
                    await self.db.execute(
                        update(VulnerabilityScan)
                        .where(VulnerabilityScan.id == vuln_scan.id)
                        .values(
                            status="completed",
                            vulnerabilities=vulnerabilities,
                            risk_score=risk_score
                        )
                    )
                    await self.db.commit()
                    
                except Exception as e:
                    logger.error(f"Vulnerability scan failed for device {device.id}: {str(e)}")
                    # Update vulnerability scan record with error
                    await self.db.execute(
                        update(VulnerabilityScan)
                        .where(VulnerabilityScan.id == vuln_scan.id)
                        .values(
                            status="error",
                            error=str(e)
                        )
                    )
                    await self.db.commit()
            
            # Update main scan record
            await self.db.execute(
                update(Scan)
                .where(Scan.id == scan_id)
                .values(
                    status="completed",
                    end_time=datetime.utcnow()
                )
            )
            await self.db.commit()
            
        except Exception as e:
            logger.error(f"Vulnerability scan {scan_id} failed: {str(e)}")
            # Update main scan record with error
            await self.db.execute(
                update(Scan)
                .where(Scan.id == scan_id)
                .values(
                    status="failed",
                    end_time=datetime.utcnow(),
                    error=str(e)
                )
            )
            await self.db.commit()
    
    async def _scan_device(self, device: Device) -> List[Dict]:
        """Scan a single device for vulnerabilities"""
        # Implementation of actual vulnerability scanning
        # This should be updated to use real vulnerability scanning
        # For now, return mock data
        return [
            {
                "name": "Test Vulnerability",
                "severity": "high",
                "description": "Test vulnerability description",
                "cve_id": "CVE-2023-0001",
                "affected_component": "Test Component",
                "recommendation": "Update to latest version"
            }
        ]
    
    def _calculate_risk_score(self, vulnerabilities: List[Dict]) -> float:
        """Calculate risk score based on vulnerabilities"""
        # Implementation of risk score calculation
        # This should be updated to use actual risk scoring
        # For now, return mock score
        return 7.5

# Create a VulnerabilityScanner factory function
def create_vulnerability_scanner(db: AsyncSession):
    """Create a new vulnerability scanner instance with the given database session"""
    return VulnerabilityScanner(db) 