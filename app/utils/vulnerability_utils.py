"""
Utilities for simulating vulnerability detection and remediation in IoT devices.
This allows for a more realistic security management workflow in the simulated environment.
"""
from typing import Dict, List, Any, Optional
from datetime import datetime
import json
import os
import logging
import random

from app.models.device import Device

logger = logging.getLogger(__name__)

# Path to store device vulnerability state
VULNERABILITY_STORE_PATH = "data/vulnerability_state.json"

# Create the data directory if it doesn't exist
os.makedirs(os.path.dirname(VULNERABILITY_STORE_PATH), exist_ok=True)

class VulnerabilityManager:
    """
    Manages the simulated vulnerabilities for devices.
    Allows for injecting and remediating vulnerabilities to simulate a security improvement workflow.
    """
    
    def __init__(self):
        self.vulnerability_state = self._load_vulnerability_state()
    
    def _load_vulnerability_state(self) -> Dict[str, Any]:
        """Load the current vulnerability state from disk"""
        try:
            if os.path.exists(VULNERABILITY_STORE_PATH):
                with open(VULNERABILITY_STORE_PATH, 'r') as f:
                    return json.load(f)
            else:
                # Initialize with empty state
                return {"devices": {}, "last_updated": datetime.utcnow().isoformat()}
        except Exception as e:
            logger.error(f"Error loading vulnerability state: {str(e)}")
            return {"devices": {}, "last_updated": datetime.utcnow().isoformat()}
    
    def _save_vulnerability_state(self) -> None:
        """Save the current vulnerability state to disk"""
        try:
            with open(VULNERABILITY_STORE_PATH, 'w') as f:
                self.vulnerability_state["last_updated"] = datetime.utcnow().isoformat()
                json.dump(self.vulnerability_state, f, indent=2)
        except Exception as e:
            logger.error(f"Error saving vulnerability state: {str(e)}")
    
    def get_device_vulnerabilities(self, device_id: str) -> List[Dict[str, Any]]:
        """
        Get the current vulnerabilities for a device.
        If the device doesn't have any recorded vulnerabilities, returns an empty list.
        """
        return self.vulnerability_state.get("devices", {}).get(device_id, {}).get("vulnerabilities", [])
    
    def detect_device_vulnerabilities(self, device: Device) -> List[Dict[str, Any]]:
        """
        Detect vulnerabilities for a device based on its properties.
        This uses both stored vulnerabilities and dynamically generated ones based on device properties.
        """
        device_id = device.hash_id
        vulnerabilities = []
        
        # Check if we have stored vulnerabilities for this device
        stored_vulns = self.get_device_vulnerabilities(device_id)
        if stored_vulns:
            vulnerabilities.extend(stored_vulns)
        
        # Dynamically generate vulnerabilities based on device properties
        # This is where we can add additional vulnerabilities based on device attributes
        dynamic_vulns = self._generate_vulnerabilities_from_device(device)
        
        # Add any new dynamic vulnerabilities that aren't already in stored_vulns
        existing_vuln_ids = {v.get("id") for v in vulnerabilities}
        for vuln in dynamic_vulns:
            if vuln.get("id") not in existing_vuln_ids:
                vulnerabilities.append(vuln)
                existing_vuln_ids.add(vuln.get("id"))
        
        # Update the stored state with the complete set
        self._update_device_vulnerabilities(device_id, vulnerabilities)
        
        return vulnerabilities
    
    def _generate_vulnerabilities_from_device(self, device: Device) -> List[Dict[str, Any]]:
        """Generate vulnerabilities based on device properties"""
        vulnerabilities = []
        
        # Check for vulnerabilities based on device properties
        # TLS Support
        if not device.supports_tls:
            vulnerabilities.append({
                "id": "CVE-2023-0001",
                "name": "Unencrypted Communication",
                "severity": "HIGH",
                "cvss_score": 8.5,
                "description": "Device communications are not encrypted with TLS/SSL",
                "affected_component": "Communication Layer",
                "recommendation": "Enable TLS/SSL for all communications",
                "remediation_complexity": "MEDIUM",
                "exploitability": "HIGH"
            })
        
        # TLS Version
        if device.tls_version and "1.0" in device.tls_version:
            vulnerabilities.append({
                "id": "CVE-2023-0002",
                "name": "Outdated TLS Version",
                "severity": "MEDIUM",
                "cvss_score": 6.0,
                "description": "Device uses an outdated TLS version vulnerable to known attacks",
                "affected_component": "Security Protocol",
                "recommendation": "Upgrade to TLS 1.2 or higher",
                "remediation_complexity": "LOW",
                "exploitability": "MEDIUM"
            })
        
        # Firmware Version (if it contains "1.0")
        if device.firmware_version and "1.0" in device.firmware_version:
            vulnerabilities.append({
                "id": "CVE-2023-0003",
                "name": "Outdated Firmware",
                "severity": "MEDIUM",
                "cvss_score": 5.5,
                "description": "Device is running outdated firmware with known security issues",
                "affected_component": "Firmware",
                "recommendation": "Update device firmware to latest version",
                "remediation_complexity": "MEDIUM",
                "exploitability": "MEDIUM"
            })
        
        # Check for insecure ports (Telnet)
        if device.ports and "23" in device.ports and device.ports.get("23") == "telnet":
            vulnerabilities.append({
                "id": "CVE-2023-0004",
                "name": "Telnet Service Enabled",
                "severity": "CRITICAL",
                "cvss_score": 9.5,
                "description": "Telnet service is enabled, allowing unencrypted remote access",
                "affected_component": "Network Services",
                "recommendation": "Disable Telnet and use SSH instead",
                "remediation_complexity": "LOW",
                "exploitability": "HIGH"
            })
        
        # Check for insecure ports (FTP)
        if device.ports and "21" in device.ports and device.ports.get("21") == "ftp":
            vulnerabilities.append({
                "id": "CVE-2023-0005",
                "name": "FTP Service Enabled",
                "severity": "HIGH",
                "cvss_score": 7.5,
                "description": "FTP service is enabled, allowing unencrypted file transfers",
                "affected_component": "Network Services",
                "recommendation": "Disable FTP and use SFTP instead",
                "remediation_complexity": "LOW",
                "exploitability": "MEDIUM"
            })
        
        # Authentication Type
        if device.auth_type == "basic" or device.auth_type == "none":
            vulnerabilities.append({
                "id": "CVE-2023-0006",
                "name": "Weak Authentication",
                "severity": "CRITICAL",
                "cvss_score": 9.0,
                "description": "Device uses weak or no authentication",
                "affected_component": "Authentication System",
                "recommendation": "Implement strong authentication mechanisms",
                "remediation_complexity": "MEDIUM",
                "exploitability": "HIGH"
            })
        
        # Randomly add one of these common IoT vulnerabilities (25% chance)
        if random.random() < 0.25:
            random_vuln = random.choice([
                {
                    "id": "CVE-2023-0007",
                    "name": "Default Credentials",
                    "severity": "CRITICAL",
                    "cvss_score": 9.8,
                    "description": "Device is using default manufacturer credentials",
                    "affected_component": "Authentication System",
                    "recommendation": "Change default passwords immediately",
                    "remediation_complexity": "LOW",
                    "exploitability": "CRITICAL"
                },
                {
                    "id": "CVE-2023-0008",
                    "name": "Hardcoded Backdoor",
                    "severity": "CRITICAL",
                    "cvss_score": 10.0,
                    "description": "Device contains a hardcoded backdoor access mechanism",
                    "affected_component": "Firmware",
                    "recommendation": "Update to latest firmware version",
                    "remediation_complexity": "MEDIUM",
                    "exploitability": "CRITICAL"
                },
                {
                    "id": "CVE-2023-0009",
                    "name": "Insecure Update Mechanism",
                    "severity": "HIGH",
                    "cvss_score": 8.2,
                    "description": "Device firmware updates are not verified or encrypted",
                    "affected_component": "Update System",
                    "recommendation": "Implement signed and encrypted updates",
                    "remediation_complexity": "HIGH",
                    "exploitability": "MEDIUM"
                }
            ])
            vulnerabilities.append(random_vuln)
        
        return vulnerabilities
    
    def _update_device_vulnerabilities(self, device_id: str, vulnerabilities: List[Dict[str, Any]]) -> None:
        """Update the stored vulnerabilities for a device"""
        if "devices" not in self.vulnerability_state:
            self.vulnerability_state["devices"] = {}
        
        if device_id not in self.vulnerability_state["devices"]:
            self.vulnerability_state["devices"][device_id] = {
                "vulnerabilities": [],
                "last_scan": datetime.utcnow().isoformat()
            }
        
        self.vulnerability_state["devices"][device_id]["vulnerabilities"] = vulnerabilities
        self.vulnerability_state["devices"][device_id]["last_scan"] = datetime.utcnow().isoformat()
        
        self._save_vulnerability_state()
    
    def inject_vulnerability(self, device_id: str, vulnerability: Dict[str, Any]) -> bool:
        """
        Manually inject a vulnerability into a device.
        This is useful for simulating newly discovered vulnerabilities.
        """
        try:
            vulnerabilities = self.get_device_vulnerabilities(device_id)
            
            # Check if vulnerability with this ID already exists
            for i, v in enumerate(vulnerabilities):
                if v.get("id") == vulnerability.get("id"):
                    # Update existing vulnerability
                    vulnerabilities[i] = vulnerability
                    self._update_device_vulnerabilities(device_id, vulnerabilities)
                    return True
            
            # Add new vulnerability
            vulnerabilities.append(vulnerability)
            self._update_device_vulnerabilities(device_id, vulnerabilities)
            return True
        except Exception as e:
            logger.error(f"Error injecting vulnerability: {str(e)}")
            return False
    
    def remediate_vulnerability(self, device_id: str, vulnerability_id: str) -> Dict[str, Any]:
        """
        Simulate remediation of a vulnerability with realistic outcomes.
        Instead of simple success/failure, this can result in:
        1. Complete fix (vulnerability removed)
        2. Partial fix (severity reduced)
        3. Temporary fix (will return after time)
        4. Failed fix (with realistic error conditions)
        
        Returns a dictionary with the remediation result details.
        """
        try:
            vulnerabilities = self.get_device_vulnerabilities(device_id)
            target_vuln = None
            target_idx = -1
            
            # Find the target vulnerability
            for i, v in enumerate(vulnerabilities):
                if v.get("id") == vulnerability_id:
                    target_vuln = v
                    target_idx = i
                    break
            
            if not target_vuln:
                logger.warning(f"Vulnerability {vulnerability_id} not found for device {device_id}")
                return {
                    "status": "error",
                    "message": f"Vulnerability {vulnerability_id} not found",
                    "device_id": device_id,
                    "vulnerability_id": vulnerability_id
                }
            
            # Determine remediation outcome based on complexity and other factors
            remediation_complexity = target_vuln.get("remediation_complexity", "MEDIUM")
            outcome_roll = random.random()
            
            # Outcome probabilities based on complexity
            if remediation_complexity == "LOW":
                # LOW complexity: 90% success, 5% partial, 5% temporary
                if outcome_roll < 0.90:
                    # Complete success - remove vulnerability
                    vulnerabilities.pop(target_idx)
                    self._update_device_vulnerabilities(device_id, vulnerabilities)
                    return {
                        "status": "success",
                        "message": f"Vulnerability {vulnerability_id} has been remediated on device {device_id}",
                        "device_id": device_id,
                        "vulnerability_id": vulnerability_id,
                        "outcome": "complete_fix",
                        "remaining_vulnerabilities": len(vulnerabilities)
                    }
                elif outcome_roll < 0.95:
                    # Partial fix - reduce severity
                    severity_levels = ["CRITICAL", "HIGH", "MEDIUM", "LOW"]
                    current_level = target_vuln.get("severity", "MEDIUM")
                    current_idx = severity_levels.index(current_level) if current_level in severity_levels else 1
                    
                    # Move down one level if not already at lowest
                    if current_idx < len(severity_levels) - 1:
                        target_vuln["severity"] = severity_levels[current_idx + 1]
                        target_vuln["partial_fix"] = True
                        target_vuln["remediation_notes"] = "Vulnerability partially mitigated but not completely fixed"
                        
                        # Update CVSS score too
                        if "cvss_score" in target_vuln:
                            target_vuln["cvss_score"] = max(2.0, target_vuln["cvss_score"] - 2.0)
                            
                        vulnerabilities[target_idx] = target_vuln
                        self._update_device_vulnerabilities(device_id, vulnerabilities)
                        return {
                            "status": "partial",
                            "message": f"Vulnerability {vulnerability_id} has been partially mitigated on device {device_id}",
                            "device_id": device_id,
                            "vulnerability_id": vulnerability_id,
                            "outcome": "partial_fix",
                            "new_severity": target_vuln["severity"],
                            "remaining_vulnerabilities": len(vulnerabilities)
                        }
                else:
                    # Temporary fix - mark for return
                    target_vuln["temporarily_fixed"] = True
                    target_vuln["fix_expiration"] = (datetime.utcnow() + timedelta(days=random.randint(30, 90))).isoformat()
                    target_vuln["remediation_notes"] = "Temporary workaround applied, will need permanent solution"
                    
                    vulnerabilities[target_idx] = target_vuln
                    self._update_device_vulnerabilities(device_id, vulnerabilities)
                    return {
                        "status": "temporary",
                        "message": f"Temporary fix applied for vulnerability {vulnerability_id} on device {device_id}",
                        "device_id": device_id,
                        "vulnerability_id": vulnerability_id,
                        "outcome": "temporary_fix",
                        "fix_expires": target_vuln["fix_expiration"],
                        "remaining_vulnerabilities": len(vulnerabilities)
                    }
            elif remediation_complexity == "MEDIUM":
                # MEDIUM complexity: 70% success, 15% partial, 10% temporary, 5% failure
                if outcome_roll < 0.70:
                    # Complete success
                    vulnerabilities.pop(target_idx)
                    self._update_device_vulnerabilities(device_id, vulnerabilities)
                    return {
                        "status": "success",
                        "message": f"Vulnerability {vulnerability_id} has been remediated on device {device_id}",
                        "device_id": device_id,
                        "vulnerability_id": vulnerability_id,
                        "outcome": "complete_fix",
                        "remaining_vulnerabilities": len(vulnerabilities)
                    }
                elif outcome_roll < 0.85:
                    # Partial fix
                    severity_levels = ["CRITICAL", "HIGH", "MEDIUM", "LOW"]
                    current_level = target_vuln.get("severity", "MEDIUM")
                    current_idx = severity_levels.index(current_level) if current_level in severity_levels else 1
                    
                    if current_idx < len(severity_levels) - 1:
                        target_vuln["severity"] = severity_levels[current_idx + 1]
                        target_vuln["partial_fix"] = True
                        target_vuln["remediation_notes"] = "Vulnerability partially mitigated but not completely fixed"
                        
                        if "cvss_score" in target_vuln:
                            target_vuln["cvss_score"] = max(2.0, target_vuln["cvss_score"] - 2.0)
                            
                        vulnerabilities[target_idx] = target_vuln
                        self._update_device_vulnerabilities(device_id, vulnerabilities)
                        return {
                            "status": "partial",
                            "message": f"Vulnerability {vulnerability_id} has been partially mitigated on device {device_id}",
                            "device_id": device_id,
                            "vulnerability_id": vulnerability_id,
                            "outcome": "partial_fix",
                            "new_severity": target_vuln["severity"],
                            "remaining_vulnerabilities": len(vulnerabilities)
                        }
                elif outcome_roll < 0.95:
                    # Temporary fix
                    target_vuln["temporarily_fixed"] = True
                    target_vuln["fix_expiration"] = (datetime.utcnow() + timedelta(days=random.randint(15, 60))).isoformat()
                    target_vuln["remediation_notes"] = "Temporary workaround applied, will need permanent solution"
                    
                    vulnerabilities[target_idx] = target_vuln
                    self._update_device_vulnerabilities(device_id, vulnerabilities)
                    return {
                        "status": "temporary",
                        "message": f"Temporary fix applied for vulnerability {vulnerability_id} on device {device_id}",
                        "device_id": device_id,
                        "vulnerability_id": vulnerability_id,
                        "outcome": "temporary_fix",
                        "fix_expires": target_vuln["fix_expiration"],
                        "remaining_vulnerabilities": len(vulnerabilities)
                    }
                else:
                    # Failed fix
                    reasons = ["Device firmware incompatible with fix", "Fix requires physical access", 
                             "Component needs replacement", "Fix requires vendor support"]
                    failure_reason = random.choice(reasons)
                    target_vuln["remediation_attempted"] = True
                    target_vuln["remediation_failed"] = True
                    target_vuln["failure_reason"] = failure_reason
                    
                    vulnerabilities[target_idx] = target_vuln
                    self._update_device_vulnerabilities(device_id, vulnerabilities)
                    return {
                        "status": "error",
                        "message": f"Failed to remediate vulnerability {vulnerability_id}: {failure_reason}",
                        "device_id": device_id,
                        "vulnerability_id": vulnerability_id,
                        "outcome": "failed_fix",
                        "failure_reason": failure_reason,
                        "remaining_vulnerabilities": len(vulnerabilities)
                    }
            else:  # HIGH complexity
                # HIGH complexity: 50% success, 20% partial, 15% temporary, 15% failure
                if outcome_roll < 0.50:
                    # Complete success
                    vulnerabilities.pop(target_idx)
                    self._update_device_vulnerabilities(device_id, vulnerabilities)
                    return {
                        "status": "success",
                        "message": f"Vulnerability {vulnerability_id} has been remediated on device {device_id}",
                        "device_id": device_id,
                        "vulnerability_id": vulnerability_id,
                        "outcome": "complete_fix",
                        "remaining_vulnerabilities": len(vulnerabilities)
                    }
                elif outcome_roll < 0.70:
                    # Partial fix
                    severity_levels = ["CRITICAL", "HIGH", "MEDIUM", "LOW"]
                    current_level = target_vuln.get("severity", "MEDIUM")
                    current_idx = severity_levels.index(current_level) if current_level in severity_levels else 1
                    
                    if current_idx < len(severity_levels) - 1:
                        target_vuln["severity"] = severity_levels[current_idx + 1]
                        target_vuln["partial_fix"] = True
                        target_vuln["remediation_notes"] = "Vulnerability partially mitigated but requires additional steps"
                        
                        if "cvss_score" in target_vuln:
                            target_vuln["cvss_score"] = max(2.0, target_vuln["cvss_score"] - 1.5)
                            
                        vulnerabilities[target_idx] = target_vuln
                        self._update_device_vulnerabilities(device_id, vulnerabilities)
                        return {
                            "status": "partial",
                            "message": f"Vulnerability {vulnerability_id} has been partially mitigated on device {device_id}",
                            "device_id": device_id,
                            "vulnerability_id": vulnerability_id,
                            "outcome": "partial_fix",
                            "new_severity": target_vuln["severity"],
                            "remaining_vulnerabilities": len(vulnerabilities)
                        }
                elif outcome_roll < 0.85:
                    # Temporary fix
                    target_vuln["temporarily_fixed"] = True
                    target_vuln["fix_expiration"] = (datetime.utcnow() + timedelta(days=random.randint(7, 30))).isoformat()
                    target_vuln["remediation_notes"] = "Complex issue with temporary workaround, requires vendor involvement"
                    
                    vulnerabilities[target_idx] = target_vuln
                    self._update_device_vulnerabilities(device_id, vulnerabilities)
                    return {
                        "status": "temporary",
                        "message": f"Temporary workaround applied for vulnerability {vulnerability_id} on device {device_id}",
                        "device_id": device_id,
                        "vulnerability_id": vulnerability_id,
                        "outcome": "temporary_fix",
                        "fix_expires": target_vuln["fix_expiration"],
                        "remaining_vulnerabilities": len(vulnerabilities)
                    }
                else:
                    # Failed fix
                    reasons = ["Device incompatible with security patch", "Requires hardware modification", 
                             "Fundamental architectural limitation", "Requires complete firmware rewrite",
                             "Vendor no longer supports this device model"]
                    failure_reason = random.choice(reasons)
                    target_vuln["remediation_attempted"] = True
                    target_vuln["remediation_failed"] = True
                    target_vuln["failure_reason"] = failure_reason
                    
                    vulnerabilities[target_idx] = target_vuln
                    self._update_device_vulnerabilities(device_id, vulnerabilities)
                    return {
                        "status": "error",
                        "message": f"Failed to remediate vulnerability {vulnerability_id}: {failure_reason}",
                        "device_id": device_id,
                        "vulnerability_id": vulnerability_id,
                        "outcome": "failed_fix",
                        "failure_reason": failure_reason,
                        "remaining_vulnerabilities": len(vulnerabilities)
                    }
        except Exception as e:
            logger.error(f"Error remediating vulnerability: {str(e)}")
            return {
                "status": "error",
                "message": f"System error during remediation: {str(e)}",
                "device_id": device_id,
                "vulnerability_id": vulnerability_id,
                "outcome": "system_error"
            }
            
    def clear_all_vulnerabilities(self) -> bool:
        """
        Clear all vulnerability data to start fresh.
        This is useful for testing or resetting the simulation.
        """
        try:
            self.vulnerability_state = {"devices": {}, "last_updated": datetime.utcnow().isoformat()}
            self._save_vulnerability_state()
            logger.info("Cleared all vulnerability data")
            return True
        except Exception as e:
            logger.error(f"Error clearing vulnerability data: {str(e)}")
            return False
    
    def bulk_remediate_vulnerabilities(self, remediation_map: Dict[str, List[str]]) -> Dict[str, Any]:
        """
        Remediate vulnerabilities across multiple devices.
        Takes a map of device_id -> list of vulnerability_ids to remediate.
        Returns statistics about the remediation operation.
        """
        results = {
            "total_devices": len(remediation_map),
            "successful_remediations": 0,
            "failed_remediations": 0,
            "vulnerabilities_fixed": 0,
            "devices": {}
        }
        
        for device_id, vuln_ids in remediation_map.items():
            device_result = {
                "successful": [],
                "failed": []
            }
            
            for vuln_id in vuln_ids:
                if self.remediate_vulnerability(device_id, vuln_id):
                    results["successful_remediations"] += 1
                    results["vulnerabilities_fixed"] += 1
                    device_result["successful"].append(vuln_id)
                else:
                    results["failed_remediations"] += 1
                    device_result["failed"].append(vuln_id)
            
            results["devices"][device_id] = device_result
        
        return results

# Create a singleton instance
vulnerability_manager = VulnerabilityManager()
